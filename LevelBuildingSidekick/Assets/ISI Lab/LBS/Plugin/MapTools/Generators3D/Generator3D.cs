using System;
using System.Collections;
using System.Collections.Generic;
using ISILab.Extensions;
using ISILab.JsonNet.Coverters;
using LBS;
using LBS.Components;
using Newtonsoft.Json;
using UnityEngine;

namespace ISILab.LBS.Generators
{
    [System.Serializable]
    public class Generator3D
    {
       
        [System.Serializable]
        public class Settings // TODO: Setting can be outside of the class to be used as general settings
        {
            [SerializeField] 
            [JsonConverter(typeof(bool))]
            public bool useBundleSize = false;
            
            [SerializeField] 
            [JsonConverter(typeof(bool))]
            public bool lightVolume = false;
            
            [SerializeField] 
            [JsonConverter(typeof(bool))]
            public bool reflectionProbe = false;
            
            [SerializeField]
            [JsonConverter(typeof(Vector2Converter))]
            public Vector2 scale = new Vector2(2, 2);

            [SerializeField]
            [JsonConverter(typeof(Vector2Converter))]
            public Vector2 resize = new Vector2(0, 0);

            [SerializeField]
            [JsonConverter(typeof(Vector3Converter))]
            public Vector3 position = new Vector3(0, 0, 0);

            [SerializeField]
            public string name = "DEFAULT";

            public override bool Equals(object obj)
            {
                var other = obj as Generator3D.Settings;

                // check if other have the same type
                if (other is not Generator3D.Settings) return false;

                // cheack if scale is the same
                if (!this.scale.Equals(other.scale)) return false;

                // cheack if resize is the same
                if (!this.resize.Equals(other.resize)) return false;

                // cheack if position is the same
                if (!this.position.Equals(other.position)) return false;

                // cheack if name is the same
                if (this.name != other.name) return false;

                if (this.useBundleSize != other.useBundleSize) return false;
                
                return true;
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }

            public override string ToString()
            {
                return base.ToString();
            }
        }  

        #region FIELDS
        [SerializeField]
        public Settings settings;

        [JsonRequired, SerializeReference]
        private List<LBSGeneratorRule> rules = new List<LBSGeneratorRule>();
        #endregion

        #region PROPERTIES
        /*
        public Vector2 Resize
        {
            get => resize;
            set => resize = value;
        }

        public Vector2 Scale
        {
            get => scale;
            set => scale = value;
        }

        public Vector3 Position
        {
            get => position;
            set => position = value;
        }

        public string ObjName
        {
            get => objName;
            set => objName = value;
        }
        */
        #endregion

        #region METHODS
        public void AddRule(LBSGeneratorRule rule)
        {
            rules.Add(rule);
            rule.generator3D = this;
        }

        public void RemoveRule(LBSGeneratorRule rule)
        {
            if (rules.Remove(rule))
                rule.generator3D = null;
        }

        public bool CheckIfIsPosible(LBSLayer layer)
        {
            foreach (var rule in rules)
            {
                var msg = "";
                var msgs = rule.CheckViability(layer); 
                if (msgs.Count > 0)
                {
                    Debug.Log(msg);
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Generates a game object that contains all the content generated by a given layer
        /// </summary>
        /// <param name="layer">An LBSLayer containing the data to be generated</param>
        /// <param name="rules">The rules that are applied to the generation</param>
        /// <param name="settings">Settings passed from the Generator</param>
        /// <returns>A tuple containing the game object and a list of messages |
        /// On successful generation: return gameObject, and empty list
        /// On failed generation: return gameObject and a list full of error message</returns>
        public Tuple<GameObject, List<string>> Generate(LBSLayer layer,List<LBSGeneratorRule> rules, Settings settings)
        {
            // each generation should have a message to indicate the reasons for failed generations
            List<string> messages = new List<string>();
            
            var name = settings.name;
            var parent = new GameObject(name);
            this.rules = rules;

            if (this.rules.Count <= 0)
            {
                messages.Add("[ISILab]: Generator contain 0 rules to generate map");
                return Tuple.Create<GameObject, List<string>>(parent, messages);
            }
            
            for (int i = 0; i < this.rules.Count; i++)
            {
                var ruleParent = rules[i].Generate(layer, settings);
                if (ruleParent.Item1 == null)
                {
                    messages.Add(ruleParent.Item2);
                    continue;
                }
                ruleParent.Item1.SetParent(parent);
            }
            return Tuple.Create<GameObject, List<string>>(parent, messages);
        }
        #endregion

    }
}